<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagnostic Aménagements Cyclables</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet Heatmap Plugin -->
    <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
    <style>
        :root {
            --primary-color: #2c3e50;
            --accent-color: #3498db;
            --bg-light: #f8f9fa;
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #map {
            height: 100vh;
            width: 100%;
            z-index: 1;
        }

        /* Panneau de contrôle personnalisé */
        #custom-legend {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            width: 280px;
            max-height: 90vh;
            overflow-y: auto;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            padding: 15px;
        }

        .legend-header {
            border-bottom: 2px solid var(--bg-light);
            margin-bottom: 15px;
            padding-bottom: 5px;
        }

        .legend-header h2 {
            margin: 0;
            font-size: 1.2rem;
            color: var(--primary-color);
        }

        .category-block {
            margin-bottom: 20px;
        }

        .category-title {
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.8rem;
            color: #7f8c8d;
            margin-bottom: 10px;
            display: block;
            border-left: 3px solid var(--accent-color);
            padding-left: 8px;
        }

        .layer-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
            padding: 6px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .layer-item:hover {
            background: var(--bg-light);
        }

        .layer-item input {
            margin-right: 10px;
            cursor: pointer;
        }

        .layer-item label {
            cursor: pointer;
            display: flex;
            align-items: center;
            width: 100%;
        }

        .symbol {
            width: 14px;
            height: 14px;
            margin-right: 10px;
            border-radius: 3px;
            display: inline-block;
            border: 1px solid rgba(0,0,0,0.2);
            flex-shrink: 0;
        }

        .symbol-heatmap {
            background: linear-gradient(to right, blue, green, yellow, red);
        }

        /* Bouton de changement de fond personnalisé */
        .basemap-toggle {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background: white;
            padding: 10px 15px;
            border-radius: 50px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            border: 2px solid #fff;
            cursor: pointer;
            font-weight: bold;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .basemap-toggle:hover {
            background: var(--bg-light);
            transform: translateY(-2px);
        }

        .basemap-toggle-icon {
            width: 20px;
            height: 20px;
            background: #eee;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        .popup-photo {
            width: 100%;
            max-width: 250px;
            border-radius: 4px;
            margin-top: 8px;
            display: block;
        }

        .popup-content b {
            color: var(--primary-color);
            display: block;
            margin-bottom: 5px;
        }

        @media (max-width: 600px) {
            #custom-legend {
                width: 220px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>

    <div id="custom-legend">
        <div class="legend-header">
            <h2>Diagnostic</h2>
        </div>
        
        <div id="category-list">
            <!-- Section Diagnostics -->
            <div class="category-block">
                <span class="category-title">Aménagement défaillant</span>
                <div id="cat-amenagement"></div>
            </div>

            <div class="category-block">
                <span class="category-title">Signalisation défaillante</span>
                <div id="cat-signalisation"></div>
            </div>

            <div class="category-block">
                <span class="category-title">Risques & Comportements</span>
                <div id="cat-comportement"></div>
            </div>

            <!-- Section Hors catégorie / Contexte -->
            <div class="category-block" style="border-top: 1px solid #eee; padding-top: 10px; margin-top: 10px;">
                <span class="category-title">Données de contexte</span>
                <div id="cat-contexte"></div>
            </div>
        </div>
    </div>

    <!-- Bouton de changement de fond -->
    <button class="basemap-toggle" onclick="toggleBasemap()">
        <div class="basemap-toggle-icon" id="toggle-preview"></div>
        <span id="toggle-text">Passer en Satellite</span>
    </button>

    <div id="map"></div>

    <script>
        // 1. Initialisation de la carte (focus sur Eysines)
        const map = L.map('map').setView([44.87826446160561, -0.6565541041113465], 14);

        // Fonds de carte
        const voyagerLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 20
        });

        const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
            maxZoom: 19
        });

        voyagerLayer.addTo(map);

        // Logique de bascule du fond de carte
        let isSatellite = false;
        function toggleBasemap() {
            if (isSatellite) {
                map.removeLayer(satelliteLayer);
                voyagerLayer.addTo(map);
                document.getElementById('toggle-text').innerText = "Passer en Satellite";
                document.getElementById('toggle-preview').style.background = "#eee";
            } else {
                map.removeLayer(voyagerLayer);
                satelliteLayer.addTo(map);
                document.getElementById('toggle-text').innerText = "Passer en Plan";
                document.getElementById('toggle-preview').style.background = "#2c3e50";
            }
            isSatellite = !isSatellite;
        }

        const layers = {};

        const layerConfigs = [
            {
                id: 'traverse',
                url: 'traverse.geojson',
                name: 'Traversée non indiquée',
                category: 'signalisation',
                color: '#e74c3c',
                weight: 5
            },
            {
                id: 'giration',
                url: 'giration.geojson',
                name: 'Angle de giration serré',
                category: 'amenagement',
                color: '#9b59b6',
                weight: 4
            },
            {
                id: 'cone',
                url: 'cone.geojson',
                name: 'Cône de visibilité',
                category: 'amenagement',
                color: '#f1c40f',
                weight: 2,
                fillOpacity: 0.4
            },
            {
                id: 'terreplein',
                url: 'terreplein.geojson',
                name: 'Terre-plein',
                category: 'amenagement',
                color: '#e67e22',
                weight: 3
            },
            {
                id: 'bandes',
                url: 'bandes.geojson',
                name: 'Bandes cyclables étroites',
                category: 'signalisation',
                color: '#3498db',
                weight: 4
            },
            {
                id: 'marquages',
                url: 'marquages.geojson',
                name: 'Marquage effacé',
                category: 'signalisation',
                color: '#95a5a6',
                weight: 4,
                dashArray: '5, 5'
            },
            {
                id: 'revetement',
                url: 'revetement.geojson',
                name: 'Revêtement défectueux',
                category: 'amenagement',
                color: '#7f8c8d',
                weight: 5,
                fillOpacity: 0.5
            },
            {
                id: 'vegetation',
                url: 'vegetation.geojson',
                name: 'Densité de végétation',
                category: 'comportement',
                isHeatmap: true,
                color: 'linear-gradient(to right, blue, green, yellow, red)'
            },
            {
                id: 'metropole',
                url: 'proprietemetropole.geojson',
                name: 'Propriété Métropole',
                category: 'contexte',
                color: '#8e44ad', // Couleur plus distincte (violet)
                weight: 3,
                fill: false,
                hiddenByDefault: true 
            },
            {
                id: 'reseauxstructurant',
                url: 'reseauxstructurant.geojson',
                name: 'Réseau Structurant',
                category: 'contexte',
                color: '#16a085', // Vert d'eau
                weight: 3,
                fill: false,
                hiddenByDefault: true
            }
        ];

        function onEachFeature(feature, layer) {
            let content = '<div class="popup-content">';
            const props = feature.properties;
            const description = props.description || props.Notes || 'Point de diagnostic';
            const photoSrc = props.photo || props.Photo;
            
            content += `<b>${description}</b>`;
            
            if (props.Date) {
                content += `<small>Date : ${props.Date}</small><br>`;
            }
            
            if (photoSrc) {
                content += `<img src="${photoSrc}" class="popup-photo" alt="Photo du diagnostic" onerror="this.style.display='none'">`;
            }
            
            content += '</div>';
            layer.bindPopup(content);
            layer.bindTooltip("Détails du diagnostic", { sticky: true });
        }

        // Calcul du rayon selon la formule demandée
        function calculateHeatRadius(zoom) {
            return 20 * Math.pow(0.85, 15 - zoom);
        }

        async function loadGeoLayer(config) {
            try {
                const response = await fetch(config.url);
                if (!response.ok) throw new Error('Fichier introuvable');
                const data = await response.json();

                let layer;

                if (config.isHeatmap) {
                    const heatPoints = data.features.map(f => {
                        return [
                            f.geometry.coordinates[1],
                            f.geometry.coordinates[0],
                            parseFloat(f.properties.intensity) || 0.5
                        ];
                    });

                    const initialRadius = calculateHeatRadius(map.getZoom());
                    
                    const heatLayer = L.heatLayer(heatPoints, {
                        radius: initialRadius,
                        blur: 15,
                        max: 0.2, 
                        gradient: {
                            0.2: 'blue', 
                            0.4: 'cyan', 
                            0.6: 'lime', 
                            0.8: 'yellow', 
                            1.0: 'red'
                        }
                    });

                    const interactionLayer = L.geoJSON(data, {
                        pointToLayer: function(feature, latlng) {
                            return L.circleMarker(latlng, {
                                radius: 20,
                                fillColor: "transparent",
                                color: "transparent",
                                stroke: false
                            });
                        },
                        onEachFeature: onEachFeature
                    });

                    layer = L.featureGroup([heatLayer, interactionLayer]);
                } else {
                    layer = L.geoJSON(data, {
                        style: function(feature) {
                            return {
                                color: config.color,
                                weight: config.weight,
                                opacity: 1, // Opacité de la ligne renforcée
                                fillColor: config.color,
                                fillOpacity: config.fill === false ? 0 : (config.fillOpacity || 0.2),
                                dashArray: config.dashArray || null
                            };
                        },
                        pointToLayer: function(feature, latlng) {
                            return L.circleMarker(latlng, {
                                radius: 8,
                                fillColor: config.color,
                                color: "#fff",
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.8
                            });
                        },
                        onEachFeature: onEachFeature
                    });
                }

                layers[config.id] = layer;
                
                if (!config.hiddenByDefault) {
                    layer.addTo(map);
                }
                
                addLayerToUI(config);

            } catch (error) {
                console.error(`Erreur chargement ${config.url}:`, error);
            }
        }

        function addLayerToUI(config) {
            const container = document.getElementById(`cat-${config.category}`);
            if (!container) return;

            const div = document.createElement('div');
            div.className = 'layer-item';
            const chkId = `chk-${config.id}`;
            const isChecked = !config.hiddenByDefault ? 'checked' : '';
            
            const symbolStyle = config.isHeatmap 
                ? `background: ${config.color};` 
                : (config.fill === false 
                    ? `border: 2px solid ${config.color}; background: transparent;` 
                    : `background-color: ${config.color}; border-bottom: ${config.dashArray ? '2px dashed #333' : '1px solid rgba(0,0,0,0.2)'}`);

            div.innerHTML = `
                <input type="checkbox" id="${chkId}" ${isChecked}>
                <label for="${chkId}">
                    <span class="symbol ${config.isHeatmap ? 'symbol-heatmap' : ''}" style="${!config.isHeatmap ? symbolStyle : ''}"></span>
                    ${config.name}
                </label>
            `;

            div.querySelector('input').addEventListener('change', (e) => {
                if (e.target.checked) {
                    if (layers[config.id]) map.addLayer(layers[config.id]);
                } else {
                    if (layers[config.id]) map.removeLayer(layers[config.id]);
                }
            });

            container.appendChild(div);
        }

        map.on('zoomend', function() {
            const currentZoom = map.getZoom();
            const newRadius = calculateHeatRadius(currentZoom);
            
            layerConfigs.forEach(config => {
                if (config.isHeatmap && layers[config.id]) {
                    layers[config.id].eachLayer(layer => {
                        if (layer.setOptions) {
                            layer.setOptions({ radius: newRadius });
                        }
                    });
                }
            });
        });

        window.onload = () => {
            layerConfigs.forEach(config => loadGeoLayer(config));
        };

    </script>
</body>
</html>
